/**
 * Autogenerated by ./generate_algorithm.sh script
 */
// Code from http://www.cplusplus.com/reference/algorithm/all_of/
template<class InputIterator, class UnaryPredicate>
  bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    if (!pred(*first)) return false;
    ++first;
  }
  return true;
}// all_of example

// Code from http://www.cplusplus.com/reference/algorithm/any_of/
template<class InputIterator, class UnaryPredicate>
  bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    if (pred(*first)) return true;
    ++first;
  }
  return false;
}// any_of example

// Code from http://www.cplusplus.com/reference/algorithm/none_of/
template<class InputIterator, class UnaryPredicate>
  bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    if (pred(*first)) return false;
    ++first;
  }
  return true;
}// none_of example

// Code from http://www.cplusplus.com/reference/algorithm/for_each/
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function fn)
{
  while (first!=last) {
    fn (*first);
    ++first;
  }
  return fn;      // or, since C++11: return move(fn);
}// for_each example

// Code from http://www.cplusplus.com/reference/algorithm/find/
template<class InputIterator, class T>
  InputIterator find (InputIterator first, InputIterator last, const T&amp; val)
{
  while (first!=last) {
    if (*first==val) return first;
    ++first;
  }
  return last;
}// find example

// Code from http://www.cplusplus.com/reference/algorithm/find_if/
template<class InputIterator, class UnaryPredicate>
  InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    if (pred(*first)) return first;
    ++first;
  }
  return last;
}// find_if example

// Code from http://www.cplusplus.com/reference/algorithm/find_if_not/
template<class InputIterator, class UnaryPredicate>
  InputIterator find_if_not (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    if (!pred(*first)) return first;
    ++first;
  }
  return last;
}// find_if_not example

// Code from http://www.cplusplus.com/reference/algorithm/find_end/
template<class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2)
{
  if (first2==last2) return last1;  // specified in C++11

  ForwardIterator1 ret = last1;

  while (first1!=last1)
  {
    ForwardIterator1 it1 = first1;
    ForwardIterator2 it2 = first2;
    while (*it1==*it2) {    // or: while (pred(*it1,*it2)) for version (2)
        ++it1; ++it2;
        if (it2==last2) { ret=first1; break; }
        if (it1==last1) return ret;
    }
    ++first1;
  }
  return ret;
}// find_end example

// Code from http://www.cplusplus.com/reference/algorithm/find_first_of/
template<class InputIterator, class ForwardIterator>
  InputIterator find_first_of ( InputIterator first1, InputIterator last1,
                                ForwardIterator first2, ForwardIterator last2)
{
  while (first1!=last1) {
    for (ForwardIterator it=first2; it!=last2; ++it) {
      if (*it==*first1)          // or: if (pred(*it,*first)) for version (2)
        return first1;
    }
    ++first1;
  }
  return last1;
}// find_first_of example

// Code from http://www.cplusplus.com/reference/algorithm/adjacent_find/
template <class ForwardIterator>
   ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last)
{
  if (first != last)
  {
    ForwardIterator next=first; ++next;
    while (next != last) {
      if (*first == *next)     // or: if (pred(*first,*next)), for version (2)
        return first;
      ++first; ++next;
    }
  }
  return last;
}// adjacent_find example

// Code from http://www.cplusplus.com/reference/algorithm/count/
template <class InputIterator, class T>
  typename iterator_traits<InputIterator>::difference_type
    count (InputIterator first, InputIterator last, const T&amp; val)
{
  typename iterator_traits<InputIterator>::difference_type ret = 0;
  while (first!=last) {
    if (*first == val) ++ret;
    ++first;
  }
  return ret;
}// count algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/count_if/
template <class InputIterator, class UnaryPredicate>
  typename iterator_traits<InputIterator>::difference_type
    count_if (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  typename iterator_traits<InputIterator>::difference_type ret = 0;
  while (first!=last) {
    if (pred(*first)) ++ret;
    ++first;
  }
  return ret;
}// count_if example

// Code from http://www.cplusplus.com/reference/algorithm/mismatch/
template <class InputIterator1, class InputIterator2>
  pair<InputIterator1, InputIterator2>
    mismatch (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )
{
  while ( (first1!=last1) &amp;&amp; (*first1==*first2) )  // or: pred(*first1,*first2), for version 2
  { ++first1; ++first2; }
  return std::make_pair(first1,first2);
}// mismatch algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/equal/
template <class InputIterator1, class InputIterator2>
  bool equal ( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )
{
  while (first1!=last1) {
    if (!(*first1 == *first2))   // or: if (!pred(*first1,*first2)), for version 2
      return false;
    ++first1; ++first2;
  }
  return true;
}// equal algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/is_permutation/
template <class InputIterator1, class InputIterator2>
  bool is_permutation (InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2)
{
  std::tie (first1,first2) = std::mismatch (first1,last1,first2);
  if (first1==last1) return true;
  InputIterator2 last2 = first2; std::advance (last2,std::distance(first1,last1));
  for (InputIterator1 it1=first1; it1!=last1; ++it1) {
    if (std::find(first1,it1,*it1)==it1) {
      auto n = std::count (first2,last2,*it1);
      if (n==0 || std::count (it1,last1,*it1)!=n) return false;
    }
  }
  return true;
}// is_permutation example

// Code from http://www.cplusplus.com/reference/algorithm/search/
template<class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1 search ( ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2)
{
  if (first2==last2) return first1;  // specified in C++11
  
  while (first1!=last1)
  {
    ForwardIterator1 it1 = first1;
    ForwardIterator2 it2 = first2;
    while (*it1==*it2) {    // or: while (pred(*it1,*it2)) for version 2
        if (it2==last2) return first1;
        if (it1==last1) return last1;
        ++it1; ++it2;
    }
    ++first1;
  }
  return last1;
}// search algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/search_n/
template<class ForwardIterator, class Size, class T>
  ForwardIterator search_n (ForwardIterator first, ForwardIterator last,
                            Size count, const T&amp; val)
{
  ForwardIterator it, limit;
  Size i;

  limit=first; std::advance(limit,std::distance(first,last)-count);

  while (first!=limit)
  {
    it = first; i=0;
    while (*it==val)       // or: while (pred(*it,val)) for the pred version
      { ++it; if (++i==count) return first; }
    ++first;
  }
  return last;
}// search_n example

// Code from http://www.cplusplus.com/reference/algorithm/copy/
template<class InputIterator, class OutputIterator>
  OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)
{
  while (first!=last) {
    *result = *first;
    ++result; ++first;
  }
  return result;
}// copy algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/copy_n/
template<class InputIterator, class Size, class OutputIterator>
  OutputIterator copy_n (InputIterator first, Size n, OutputIterator result)
{
  while (n>0) {
    *result = *first;
    ++result; ++first;
    --n;
  }
  return result;
}// copy_n algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/copy_if/
template <class InputIterator, class OutputIterator, class UnaryPredicate>
  OutputIterator copy_if (InputIterator first, InputIterator last,
                          OutputIterator result, UnaryPredicate pred)
{
  while (first!=last) {
    if (pred(*first)) {
      *result = *first;
      ++result;
    }
    ++first;
  }
  return result;
}// copy_if example

// Code from http://www.cplusplus.com/reference/algorithm/copy_backward/
template<class BidirectionalIterator1, class BidirectionalIterator2>
  BidirectionalIterator2 copy_backward ( BidirectionalIterator1 first,
                                         BidirectionalIterator1 last,
                                         BidirectionalIterator2 result )
{
  while (last!=first) *(--result) = *(--last);
  return result;
}// copy_backward example

// Code from http://www.cplusplus.com/reference/algorithm/move/
template<class InputIterator, class OutputIterator>
  OutputIterator move (InputIterator first, InputIterator last, OutputIterator result)
{
  while (first!=last) {
    *result = std::move(*first);
    ++result; ++first;
  }
  return result;
}// move algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/move_backward/
template<class BidirectionalIterator1, class BidirectionalIterator2>
  BidirectionalIterator2 move_backward ( BidirectionalIterator1 first,
                                         BidirectionalIterator1 last,
                                         BidirectionalIterator2 result )
{
  while (last!=first) *(--result) = std::move(*(--last));
  return result;
}// move_backward example

// Code from http://www.cplusplus.com/reference/algorithm/swap/
template <class T> void swap ( T&amp; a, T&amp; b )
{
  T c(a); a=b; b=c;
}template <class T> void swap (T&amp; a, T&amp; b)
{
  T c(std::move(a)); a=std::move(b); b=std::move(c);
}
template <class T, size_t N> void swap (T (&amp;a)[N], T (&amp;b)[N])
{
  for (size_t i = 0; i<N; ++i) swap (a[i],b[i]);
}// swap algorithm example (C++98)

// Code from http://www.cplusplus.com/reference/algorithm/swap_ranges/
template<class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 swap_ranges (ForwardIterator1 first1, ForwardIterator1 last1,
                                ForwardIterator2 first2)
{
  while (first1!=last1) {
    swap (*first1, *first2);
    ++first1; ++first2;
  }
  return first2;
}// swap_ranges example

// Code from http://www.cplusplus.com/reference/algorithm/iter_swap/
template <class ForwardIterator1, class ForwardIterator2>
  void iter_swap (ForwardIterator1 a, ForwardIterator2 b)
{
  swap (*a, *b);
}// iter_swap example

// Code from http://www.cplusplus.com/reference/algorithm/transform/
template <class InputIterator, class OutputIterator, class UnaryOperator>
  OutputIterator transform (InputIterator first1, InputIterator last1,
                            OutputIterator result, UnaryOperator op)
{
  while (first1 != last1) {
    *result = op(*first1);  // or: *result=binary_op(*first1,*first2++);
    ++result; ++first1;
  }
  return result;
}// transform algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/replace/
template <class ForwardIterator, class T>
  void replace (ForwardIterator first, ForwardIterator last,
                const T&amp; old_value, const T&amp; new_value)
{
  while (first!=last) {
    if (*first == old_value) *first=new_value;
    ++first;
  }
}// replace algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/replace_if/
template < class ForwardIterator, class UnaryPredicate, class T >
  void replace_if (ForwardIterator first, ForwardIterator last,
                   UnaryPredicate pred, const T&amp; new_value)
{
  while (first!=last) {
    if (pred(*first)) *first=new_value;
    ++first;
  }
}// replace_if example

// Code from http://www.cplusplus.com/reference/algorithm/replace_copy/
template <class InputIterator, class OutputIterator, class T>
  OutputIterator replace_copy (InputIterator first, InputIterator last,
                               OutputIterator result, const T&amp; old_value, const T&amp; new_value)
{
  while (first!=last) {
    *result = (*first==old_value)? new_value: *first;
    ++first; ++result;
  }
  return result;
}// replace_copy example

// Code from http://www.cplusplus.com/reference/algorithm/replace_copy_if/
template <class InputIterator, class OutputIterator, class UnaryPredicate, class T>
  OutputIterator replace_copy_if (InputIterator first, InputIterator last,
                                  OutputIterator result, UnaryPredicate pred,
                                  const T&amp; new_value)
{
  while (first!=last) {
    *result = (pred(*first))? new_value: *first;
    ++first; ++result;
  }
  return result;
}// replace_copy_if example

// Code from http://www.cplusplus.com/reference/algorithm/fill/
template <class ForwardIterator, class T>
  void fill (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  while (first != last) {
    *first = val;
    ++first;
  }
}// fill algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/fill_n/
template <class OutputIterator, class Size, class T>
  OutputIterator fill_n (OutputIterator first, Size n, const T&amp; val)
{
  while (n>0) {
    *first = val;
    ++first; --n;
  }
  return first;     // since C++11
}// fill_n example

// Code from http://www.cplusplus.com/reference/algorithm/generate/
template <class ForwardIterator, class Generator>
  void generate ( ForwardIterator first, ForwardIterator last, Generator gen )
{
  while (first != last) {
    *first = gen();
    ++first;
  }
}// generate algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/generate_n/
template <class OutputIterator, class Size, class Generator>
  void generate_n ( OutputIterator first, Size n, Generator gen )
{
  while (n>0) {
    *first = gen();
    ++first; --n;
  }
}// generate_n example

// Code from http://www.cplusplus.com/reference/algorithm/remove/
template <class ForwardIterator, class T>
  ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  ForwardIterator result = first;
  while (first!=last) {
    if (!(*first == val)) {
      *result = *first;
      ++result;
    }
    ++first;
  }
  return result;
}template <class ForwardIterator, class T>
  ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  ForwardIterator result = first;
  while (first!=last) {
    if (!(*first == val)) {
      *result = move(*first);
      ++result;
    }
    ++first;
  }
  return result;
}// remove algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/remove_if/
template <class ForwardIterator, class UnaryPredicate>
  ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,
                             UnaryPredicate pred)
{
  ForwardIterator result = first;
  while (first!=last) {
    if (!pred(*first)) {
      *result = *first;
      ++result;
    }
    ++first;
  }
  return result;
}template <class ForwardIterator, class UnaryPredicate>
  ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,
                             UnaryPredicate pred)
{
  ForwardIterator result = first;
  while (first!=last) {
    if (!pred(*first)) {
      *result = std::move(*first);
      ++result;
    }
    ++first;
  }
  return result;
}// remove_if example

// Code from http://www.cplusplus.com/reference/algorithm/remove_copy/
template <class InputIterator, class OutputIterator, class T>
  OutputIterator remove_copy (InputIterator first, InputIterator last,
                              OutputIterator result, const T&amp; val)
{
  while (first!=last) {
    if (!(*first == val)) {
      *result = *first;
      ++result;
    }
    ++first;
  }
  return result;
}// remove_copy example

// Code from http://www.cplusplus.com/reference/algorithm/remove_copy_if/
template <class InputIterator, class OutputIterator, class UnaryPredicate>
  OutputIterator remove_copy_if (InputIterator first, InputIterator last,
                                 OutputIterator result, UnaryPredicate pred)
{
  while (first!=last) {
    if (!pred(*first)) {
      *result = *first;
      ++result;
    }
    ++first;
  }
  return result;
}// remove_copy_if example

// Code from http://www.cplusplus.com/reference/algorithm/unique/
template <class ForwardIterator>
  ForwardIterator unique (ForwardIterator first, ForwardIterator last)
{
  if (first==last) return last;

  ForwardIterator result = first;
  while (++first != last)
  {
    if (!(*result == *first))  // or: if (!pred(*result,*first)) for version (2)
      *(++result)=*first;
  }
  return ++result;
}// unique algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/unique_copy/
template <class InputIterator, class OutputIterator>
  OutputIterator unique_copy (InputIterator first, InputIterator last,
                              OutputIterator result)
{
  if (first==last) return result;

  *result = *first;
  while (++first != last) {
    typename iterator_traits<InputIterator>::value_type val = *first;
    if (!(*result == val))   // or: if (!pred(*result,val)) for version (2)
      *(++result)=val;
  }
  return ++result;
}// unique_copy example

// Code from http://www.cplusplus.com/reference/algorithm/reverse/
template <class BidirectionalIterator>
  void reverse (BidirectionalIterator first, BidirectionalIterator last)
{
  while ((first!=last)&amp;&amp;(first!=--last)) {
    std::iter_swap (first,last);
    ++first;
  }
}// reverse algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/reverse_copy/
template <class BidirectionalIterator, class OutputIterator>
  OutputIterator reverse_copy (BidirectionalIterator first,
                               BidirectionalIterator last, OutputIterator result)
{
  while (first!=last) {
    --last;
    *result = *last;
    ++result;
  }
  return result;
}// reverse_copy example

// Code from http://www.cplusplus.com/reference/algorithm/rotate/
template <class ForwardIterator>
  void rotate (ForwardIterator first, ForwardIterator middle,
               ForwardIterator last)
{
  ForwardIterator next = middle;
  while (first!=next)
  {
    swap (*first++,*next++);
    if (next==last) next=middle;
    else if (first==middle) middle=next;
  }
}// rotate algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/rotate_copy/
template <class ForwardIterator, class OutputIterator>
  OutputIterator rotate_copy (ForwardIterator first, ForwardIterator middle,
                              ForwardIterator last, OutputIterator result)
{
  result=std::copy (middle,last,result);
  return std::copy (first,middle,result);
}// rotate_copy algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/random_shuffle/
template <class RandomAccessIterator, class RandomNumberGenerator>
  void random_shuffle (RandomAccessIterator first, RandomAccessIterator last,
                       RandomNumberGenerator&amp; gen)
{
  iterator_traits<RandomAccessIterator>::difference_type i, n;
  n = (last-first);
  for (i=n-1; i>0; --i) {
    swap (first[i],first[gen(i+1)]);
  }
}// random_shuffle example

// Code from http://www.cplusplus.com/reference/algorithm/shuffle/
template <class RandomAccessIterator, class URNG>
  void shuffle (RandomAccessIterator first, RandomAccessIterator last, URNG&amp;&amp; g)
{
  for (auto i=(last-first)-1; i>0; --i) {
    std::uniform_int_distribution<decltype(i)> d(0,i);
    swap (first[i], first[d(g)]);
  }
}// shuffle algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/is_partitioned/
template <class InputIterator, class UnaryPredicate>
  bool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred)
{
  while (first!=last &amp;&amp; pred(*first)) {
    ++first;
  }
  while (first!=last) {
    if (pred(*first)) return false;
    ++first;
  }
  return true;
}// is_partitioned example

// Code from http://www.cplusplus.com/reference/algorithm/partition/
template <class BidirectionalIterator, class UnaryPredicate>
  BidirectionalIterator partition (BidirectionalIterator first,
                                   BidirectionalIterator last, UnaryPredicate pred)
{
  while (first!=last) {
    while (pred(*first)) {
      ++first;
      if (first==last) return first;
    }
    do {
      --last;
      if (first==last) return first;
    } while (!pred(*last));
    swap (*first,*last);
    ++first;
  }
  return first;
}// partition algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/stable_partition/
// stable_partition example

// Code from http://www.cplusplus.com/reference/algorithm/partition_copy/
template <class InputIterator, class OutputIterator1,
          class OutputIterator2, class UnaryPredicate pred>
  pair<OutputIterator1,OutputIterator2>
    partition_copy (InputIterator first, InputIterator last,
                    OutputIterator1 result_true, OutputIterator2 result_false,
                    UnaryPredicate pred)
{
  while (first!=last) {
    if (pred(*first)) {
      *result_true = *first;
      ++result_true;
    }
    else {
      *result_false = *first;
      ++result_false;
    }
    ++first;
  }
  return std::make_pair (result_true,result_false);
}// partition_copy example

// Code from http://www.cplusplus.com/reference/algorithm/partition_point/
template <class ForwardIterator, class UnaryPredicate>
  ForwardIterator partition_point (ForwardIterator first, ForwardIterator last,
                                   UnaryPredicate pred)
{
  auto n = distance(first,last);
  while (n>0)
  {
    ForwardIterator it = first;
    auto step = n/2;
    std::advance (it,step);
    if (pred(*it)) { first=++it; n-=step+1; }
    else n=step;
  }
  return first;
}// partition_point example

// Code from http://www.cplusplus.com/reference/algorithm/sort/
// sort algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/stable_sort/
// stable_sort example

// Code from http://www.cplusplus.com/reference/algorithm/partial_sort/
// partial_sort example

// Code from http://www.cplusplus.com/reference/algorithm/partial_sort_copy/
// partial_sort_copy example

// Code from http://www.cplusplus.com/reference/algorithm/is_sorted/
template <class ForwardIterator>
  bool is_sorted (ForwardIterator first, ForwardIterator last)
{
  if (first==last) return true;
  ForwardIterator next = first;
  while (++next!=last) {
    if (*next<*first)     // or, if (comp(*next,*first)) for version (2)
      return false;
    ++first;
  }
  return true;
}// is_sorted example

// Code from http://www.cplusplus.com/reference/algorithm/is_sorted_until/
template <class ForwardIterator>
  ForwardIterator is_sorted_until (ForwardIterator first, ForwardIterator last)
{
  if (first==last) return first;
  ForwardIterator next = first;
  while (++next!=last) {
    if (*next<*first) return next;
    ++first;
  }
  return last;
}// is_sorted_until example

// Code from http://www.cplusplus.com/reference/algorithm/nth_element/
// nth_element example

// Code from http://www.cplusplus.com/reference/algorithm/lower_bound/
template <class ForwardIterator, class T>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; advance (it,step);
    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)
      first=++it;
      count-=step+1;
    }
    else count=step;
  }
  return first;
}// lower_bound/upper_bound example

// Code from http://www.cplusplus.com/reference/algorithm/upper_bound/
template <class ForwardIterator, class T>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = std::distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; std::advance (it,step);
    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)
      { first=++it; count-=step+1;  }
    else count=step;
  }
  return first;
}// lower_bound/upper_bound example

// Code from http://www.cplusplus.com/reference/algorithm/equal_range/
template <class ForwardIterator, class T>
  pair<ForwardIterator,ForwardIterator>
    equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  ForwardIterator it = std::lower_bound (first,last,val);
  return std::make_pair ( it, std::upper_bound(it,last,val) );
}// equal_range example
// equal_range example

// Code from http://www.cplusplus.com/reference/algorithm/binary_search/
template <class ForwardIterator, class T>
  bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp; val)
{
  first = std::lower_bound(first,last,val);
  return (first!=last &amp;&amp; !(val<*first));
}// binary_search example

// Code from http://www.cplusplus.com/reference/algorithm/merge/
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator merge (InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputIterator result)
{
  while (true) {
    if (first1==last1) return std::copy(first2,last2,result);
    if (first2==last2) return std::copy(first1,last1,result);
    *result++ = (*first2<*first1)? *first2++ : *first1++;
  }
}// merge algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/inplace_merge/
// inplace_merge example

// Code from http://www.cplusplus.com/reference/algorithm/includes/
template <class InputIterator1, class InputIterator2>
  bool includes (InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, InputIterator2 last2)
{
  while (first2!=last2) {
    if ( (first1==last1) || (*first2<*first1) ) return false;
    if (!(*first1<*first2)) ++first2;
    ++first1;
  }
  return true;
}// includes algorithm example

// Code from http://www.cplusplus.com/reference/algorithm/set_union/
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator set_union (InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            OutputIterator result)
{
  while (true)
  {
    if (first1==last1) return std::copy(first2,last2,result);
    if (first2==last2) return std::copy(first1,last1,result);

    if (*first1<*first2) { *result = *first1; ++first1; }
    else if (*first2<*first1) { *result = *first2; ++first2; }
    else { *result = *first1; ++first1; ++first2; }
    ++result;
  }
}// set_union example

// Code from http://www.cplusplus.com/reference/algorithm/set_intersection/
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator set_intersection (InputIterator1 first1, InputIterator1 last1,
                                   InputIterator2 first2, InputIterator2 last2,
                                   OutputIterator result)
{
  while (first1!=last1 &amp;&amp; first2!=last2)
  {
    if (*first1<*first2) ++first1;
    else if (*first2<*first1) ++first2;
    else {
      *result = *first1;
      ++result; ++first1; ++first2;
    }
  }
  return result;
}// set_intersection example

// Code from http://www.cplusplus.com/reference/algorithm/set_difference/
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator set_difference (InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2,
                                 OutputIterator result)
{
  while (first1!=last1 &amp;&amp; first2!=last2)
  {
    if (*first1<*first2) { *result = *first1; ++result; ++first1; }
    else if (*first2<*first1) ++first2;
    else { ++first1; ++first2; }
  }
  return std::copy(first1,last1,result);
}// set_difference example

// Code from http://www.cplusplus.com/reference/algorithm/set_symmetric_difference/
template <class InputIterator1, class InputIterator2, class OutputIterator>
  OutputIterator set_symmetric_difference (InputIterator1 first1, InputIterator1 last1,
                                           InputIterator2 first2, InputIterator2 last2,
                                           OutputIterator result)
{
  while (true)
  {
    if (first1==last1) return std::copy(first2,last2,result);
    if (first2==last2) return std::copy(first1,last1,result);

    if (*first1<*first2) { *result=*first1; ++result; ++first1; }
    else if (*first2<*first1) { *result = *first2; ++result; ++first2; }
    else { ++first1; ++first2; }
  }
}// set_symmetric_difference example

// Code from http://www.cplusplus.com/reference/algorithm/push_heap/
// range heap example

// Code from http://www.cplusplus.com/reference/algorithm/pop_heap/
// range heap example

// Code from http://www.cplusplus.com/reference/algorithm/make_heap/
// range heap example

// Code from http://www.cplusplus.com/reference/algorithm/sort_heap/
// range heap example

// Code from http://www.cplusplus.com/reference/algorithm/is_heap/
// is_heap example

// Code from http://www.cplusplus.com/reference/algorithm/is_heap_until/
// is_heap example

// Code from http://www.cplusplus.com/reference/algorithm/min/
template <class T> const T&amp; min (const T&amp; a, const T&amp; b) {
  return !(b<a)?a:b;     // or: return !comp(b,a)?a:b; for version (2)
}// min example

// Code from http://www.cplusplus.com/reference/algorithm/max/
template <class T> const T&amp; max (const T&amp; a, const T&amp; b) {
  return (a<b)?b:a;     // or: return comp(a,b)?b:a; for version (2)
}// max example

// Code from http://www.cplusplus.com/reference/algorithm/minmax/
template <class T> pair <const T&amp;,const T&amp;> minmax (const T&amp; a, const T&amp; b) {
  return (b<a) ? std::make_pair(b,a) : std::make_pair(a,b);
}// minmax example

// Code from http://www.cplusplus.com/reference/algorithm/min_element/
template <class ForwardIterator>
  ForwardIterator min_element ( ForwardIterator first, ForwardIterator last )
{
  if (first==last) return last;
  ForwardIterator smallest = first;

  while (++first!=last)
    if (*first<*smallest)    // or: if (comp(*first,*smallest)) for version (2)
      smallest=first;
  return smallest;
}// min_element/max_element example

// Code from http://www.cplusplus.com/reference/algorithm/max_element/
template <class ForwardIterator>
  ForwardIterator max_element ( ForwardIterator first, ForwardIterator last )
{
  if (first==last) return last;
  ForwardIterator largest = first;

  while (++first!=last)
    if (*largest<*first)    // or: if (comp(*largest,*first)) for version (2)
      largest=first;
  return largest;
}// min_element/max_element example

// Code from http://www.cplusplus.com/reference/algorithm/minmax_element/
// minmax_element

// Code from http://www.cplusplus.com/reference/algorithm/lexicographical_compare/
template <class InputIterator1, class InputIterator2>
  bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,
                                InputIterator2 first2, InputIterator2 last2)
{
  while (first1!=last1)
  {
    if (first2==last2 || *first2<*first1) return false;
    else if (*first1<*first2) return true;
    ++first1; ++first2;
  }
  return (first2!=last2);
}// lexicographical_compare example

// Code from http://www.cplusplus.com/reference/algorithm/next_permutation/
// next_permutation example

// Code from http://www.cplusplus.com/reference/algorithm/prev_permutation/
// next_permutation example

